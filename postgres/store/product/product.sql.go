// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: product.sql

package product

import (
	"context"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    store_id, category_id, name, brand, slug, short_info, image_urls, specs, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, store_id, category_id, name, brand, slug, short_info, image_urls, specs, status, created_at, updated_at
`

func (q *Queries) CreateProduct(ctx context.Context, storeID int32, categoryID int32, name string, brand *string, slug string, shortInfo []string, imageUrls ImageUrls, specs Specs, status ProductStatus) (*Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		storeID,
		categoryID,
		name,
		brand,
		slug,
		shortInfo,
		imageUrls,
		specs,
		status,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.CategoryID,
		&i.Name,
		&i.Brand,
		&i.Slug,
		&i.ShortInfo,
		&i.ImageUrls,
		&i.Specs,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    p.id, p.store_id, p.category_id, p.name, p.brand, p.slug, p.short_info, p.image_urls, p.specs, p.status, p.created_at, p.updated_at,
    s.id, s.public_id, s.seller_id, s.name, s.description, s.created_at, s.updated_at,
    pp.product_id, pp.base_price, pp.currency_code, pp.discount_level, pp.discounted_amount, pp.is_on_sale
FROM
    products p
        LEFT JOIN
            product_pricing pp ON pp.product_id = p.id
        LEFT JOIN
            seller_stores s ON s.id = p.store_id
WHERE
    p.id = $1
`

type GetProductByIDRow struct {
	Product        Product
	SellerStore    SellerStore
	ProductPricing ProductPricing
}

func (q *Queries) GetProductByID(ctx context.Context, id int64) (*GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.Product.ID,
		&i.Product.StoreID,
		&i.Product.CategoryID,
		&i.Product.Name,
		&i.Product.Brand,
		&i.Product.Slug,
		&i.Product.ShortInfo,
		&i.Product.ImageUrls,
		&i.Product.Specs,
		&i.Product.Status,
		&i.Product.CreatedAt,
		&i.Product.UpdatedAt,
		&i.SellerStore.ID,
		&i.SellerStore.PublicID,
		&i.SellerStore.SellerID,
		&i.SellerStore.Name,
		&i.SellerStore.Description,
		&i.SellerStore.CreatedAt,
		&i.SellerStore.UpdatedAt,
		&i.ProductPricing.ProductID,
		&i.ProductPricing.BasePrice,
		&i.ProductPricing.CurrencyCode,
		&i.ProductPricing.DiscountLevel,
		&i.ProductPricing.DiscountedAmount,
		&i.ProductPricing.IsOnSale,
	)
	return &i, err
}

const getProductsByCategoryIDs = `-- name: GetProductsByCategoryIDs :many
SELECT id, store_id, category_id, name, brand, slug, short_info, image_urls, specs, status, created_at, updated_at FROM products
WHERE category_id = ANY($3::INT[])
OFFSET $1
LIMIT $2
`

func (q *Queries) GetProductsByCategoryIDs(ctx context.Context, offset int32, limit int32, leafCategoryIds []int32) ([]*Product, error) {
	rows, err := q.db.Query(ctx, getProductsByCategoryIDs, offset, limit, leafCategoryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.CategoryID,
			&i.Name,
			&i.Brand,
			&i.Slug,
			&i.ShortInfo,
			&i.ImageUrls,
			&i.Specs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
