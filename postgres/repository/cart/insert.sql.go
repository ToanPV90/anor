// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: insert.sql

package cart

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const addCartItem = `-- name: AddCartItem :one
INSERT INTO cart_items (
    cart_id, variant_id, qty, price, currency, thumbnail, product_name, product_path, variant_attributes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, cart_id, variant_id, qty, price, currency, thumbnail, product_name, product_path, variant_attributes, is_removed, created_at, updated_at
`

func (q *Queries) AddCartItem(ctx context.Context, cartID int64, variantID int64, qty int32, price decimal.Decimal, currency string, thumbnail string, productName string, productPath string, variantAttributes []byte) (*CartItem, error) {
	row := q.db.QueryRow(ctx, addCartItem,
		cartID,
		variantID,
		qty,
		price,
		currency,
		thumbnail,
		productName,
		productPath,
		variantAttributes,
	)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.VariantID,
		&i.Qty,
		&i.Price,
		&i.Currency,
		&i.Thumbnail,
		&i.ProductName,
		&i.ProductPath,
		&i.VariantAttributes,
		&i.IsRemoved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createCart = `-- name: CreateCart :one
INSERT INTO carts (
    user_id
) VALUES (
    $1
) RETURNING id, user_id, status, last_activity, expires_at, created_at, updated_at
`

func (q *Queries) CreateCart(ctx context.Context, userID *int64) (*Cart, error) {
	row := q.db.QueryRow(ctx, createCart, userID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.LastActivity,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createGuestCart = `-- name: CreateGuestCart :one
INSERT INTO carts (
    expires_at
) VALUES (
    $1
) RETURNING id, user_id, status, last_activity, expires_at, created_at, updated_at
`

func (q *Queries) CreateGuestCart(ctx context.Context, expiresAt pgtype.Timestamptz) (*Cart, error) {
	row := q.db.QueryRow(ctx, createGuestCart, expiresAt)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.LastActivity,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const mergeGuestCartWithUserCart = `-- name: MergeGuestCartWithUserCart :exec
INSERT INTO cart_items (cart_id, variant_id, qty, price, thumbnail, product_name, product_path, variant_attributes, is_removed, created_at, updated_at)
SELECT
    user_cart.id, -- Use the user's cart id
    guest_items.variant_id,
    CASE
        WHEN user_items.qty IS NULL THEN guest_items.qty
        WHEN user_items.qty >= guest_items.qty THEN user_items.qty
        ELSE guest_items.qty
        END AS qty,
    guest_items.price,
    guest_items.thumbnail,
    guest_items.product_name,
    guest_items.product_path,
    guest_items.variant_attributes,
    guest_items.is_removed,
    LEAST(guest_items.created_at, COALESCE(user_items.created_at, guest_items.created_at)) AS created_at,
    CURRENT_TIMESTAMP AS updated_at
FROM
    cart_items guest_items
        JOIN
    carts guest_cart ON guest_items.cart_id = guest_cart.id
        CROSS JOIN
    carts user_cart
        LEFT JOIN
    cart_items user_items ON user_items.cart_id = user_cart.id AND user_items.variant_id = guest_items.variant_id
WHERE
    guest_cart.id = $1  -- Use $1 for guest_cart_id
  AND user_cart.id = $2  -- Use $2 for user_cart_id
  AND (user_items.id IS NULL OR guest_items.qty > user_items.qty)
ON CONFLICT (cart_id, variant_id)
    DO UPDATE SET
                  qty = EXCLUDED.qty,
                  updated_at = CURRENT_TIMESTAMP
`

func (q *Queries) MergeGuestCartWithUserCart(ctx context.Context, guestCartID int64, userCartID int64) error {
	_, err := q.db.Exec(ctx, mergeGuestCartWithUserCart, guestCartID, userCartID)
	return err
}
