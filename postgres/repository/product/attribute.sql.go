// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: attribute.sql

package product

import (
	"context"
)

const createProductAttribute = `-- name: CreateProductAttribute :one
INSERT INTO product_attributes (
    product_id, attribute
) VALUES (
    $1, $2
) RETURNING id, product_id, attribute
`

func (q *Queries) CreateProductAttribute(ctx context.Context, productID int64, attribute string) (*ProductAttribute, error) {
	row := q.db.QueryRow(ctx, createProductAttribute, productID, attribute)
	var i ProductAttribute
	err := row.Scan(&i.ID, &i.ProductID, &i.Attribute)
	return &i, err
}

const createProductVariantAttributeValues = `-- name: CreateProductVariantAttributeValues :exec
INSERT INTO product_variant_attributes (
    variant_id, product_attribute_id, attribute_value
) VALUES (
    $1, $2, $3
)
`

func (q *Queries) CreateProductVariantAttributeValues(ctx context.Context, variantID int64, productAttributeID int64, attributeValue string) error {
	_, err := q.db.Exec(ctx, createProductVariantAttributeValues, variantID, productAttributeID, attributeValue)
	return err
}

const getProductAttributesByCategoryID = `-- name: GetProductAttributesByCategoryID :many
SELECT DISTINCT
    pa.attribute,
    array_agg(DISTINCT pva.attribute_value ORDER BY pva.attribute_value)::text[] AS values
FROM
    products p
        JOIN
    product_attributes pa ON p.id = pa.product_id
        JOIN
    product_variants pv ON p.id = pv.product_id
        JOIN
    product_variant_attributes pva ON pv.id = pva.variant_id
WHERE
    p.category_id = $1
GROUP BY
    pa.attribute
`

type GetProductAttributesByCategoryIDRow struct {
	Attribute string
	Values    []string
}

func (q *Queries) GetProductAttributesByCategoryID(ctx context.Context, categoryID int32) ([]*GetProductAttributesByCategoryIDRow, error) {
	rows, err := q.db.Query(ctx, getProductAttributesByCategoryID, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductAttributesByCategoryIDRow
	for rows.Next() {
		var i GetProductAttributesByCategoryIDRow
		if err := rows.Scan(&i.Attribute, &i.Values); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAttributesByCategoryIDs = `-- name: GetProductAttributesByCategoryIDs :many
SELECT DISTINCT
    pa.attribute,
    array_agg(DISTINCT pva.attribute_value ORDER BY pva.attribute_value)::text[] AS values
FROM
    products p
        JOIN
    product_attributes pa ON p.id = pa.product_id
        JOIN
    product_variants pv ON p.id = pv.product_id
        JOIN
    product_variant_attributes pva ON pv.id = pva.variant_id
WHERE
    p.category_id = ANY($1::INT[])
GROUP BY
    pa.attribute
`

type GetProductAttributesByCategoryIDsRow struct {
	Attribute string
	Values    []string
}

func (q *Queries) GetProductAttributesByCategoryIDs(ctx context.Context, leafcategoryids []int32) ([]*GetProductAttributesByCategoryIDsRow, error) {
	rows, err := q.db.Query(ctx, getProductAttributesByCategoryIDs, leafcategoryids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductAttributesByCategoryIDsRow
	for rows.Next() {
		var i GetProductAttributesByCategoryIDsRow
		if err := rows.Scan(&i.Attribute, &i.Values); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAttributesByProductID = `-- name: GetProductAttributesByProductID :many
SELECT
    pa.attribute AS attribute_name,
    ARRAY_AGG(DISTINCT pva.attribute_value)::text[] AS attribute_values
FROM
    product_attributes pa
        JOIN
            product_variant_attributes pva ON pa.id = pva.product_attribute_id
WHERE
    pa.product_id = $1
GROUP BY
    pa.attribute
`

type GetProductAttributesByProductIDRow struct {
	AttributeName   string
	AttributeValues []string
}

func (q *Queries) GetProductAttributesByProductID(ctx context.Context, productID int64) ([]*GetProductAttributesByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getProductAttributesByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProductAttributesByProductIDRow
	for rows.Next() {
		var i GetProductAttributesByProductIDRow
		if err := rows.Scan(&i.AttributeName, &i.AttributeValues); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
